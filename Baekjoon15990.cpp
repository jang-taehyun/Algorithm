/*
problem : 정수 n을 1,2,3의 합으로 나타내되, 같은 수를 두 번 이상 연속으로 사용하지 않고 나타내는 방법의 수
input : 정수 n
output : 정수 n을 1,2,3의 합으로 나타내는 방법의 수 k

idea : bottom-up 방식으로 표를 이용해 해결
                              n=1        n=2        n=3        n=4        n=5
오른쪽에 1을 추가하는 경우       1         없음       2+1     1+2+1, 3+1    1+3+1
오른쪽에 2를 추가하는 경우      없음         2        1+2        없음     2+1+2, 3+2
오른쪽에 3을 추가하는 경우      없음        없음        3         1+3        3+2
1. n=4일 때, k=3
   1) 오른쪽에 1을 추가하는 경우 : n=3에서 오른쪽에 2를 추가하는 경우 + n=3에서 오른쪽에 3을 추가하는 경우
      -> 1+2+1, 3+1
      -> 2개
   2) 오른쪽에 2을 추가하는 경우 : n=2에서 오른쪽에 1를 추가하는 경우 + n=2에서 오른쪽에 3을 추가하는 경우
      -> 없음
   3) 오른쪽에 3을 추가하는 경우 : n=1에서 오른쪽에 1를 추가하는 경우 + n=1에서 오른쪽에 2을 추가하는 경우
      -> 1+3
      -> 1개
2. 이를 이용해 관계식 도출
   -> DP[i][n] : 정수 n을 1,2,3의 합으로 만드는 방법의 수 중 오른쪽에 정수 i가 있는 방법의 수(i = 1,2,3)
   -> k = DP[1][n] + DP[2][n] + DP[3][n]
      DP[1][n] = DP[2][n-1] + DP[3][n-1]
      DP[2][n] = DP[1][n-2] + DP[3][n-2]
      DP[3][n] = DP[1][n-3] + DP[2][n-3]
*/

#include <iostream>
using namespace std;

// 관계식 DP[i][n] : 정수 n을 1,2,3의 합으로 만드는 방법의 수 중 오른쪽에 정수 i가 있는 방법의 수(i = 1,2,3)
// DP 계산시, 최악의 경우 DP[i][n]이 10억 가까이 되므로 int 대신 long long 자료형(8byte) 사용
long long DP[4][100001];

int main()
{
    // 테스트할 횟수
    int testCase = 0;
    // 입력받을 정수
    int input = 0;

    // n=1, n=2, n=3일 때 DP 초기화
    DP[1][1] = 1;
    DP[2][1] = 0;
    DP[3][1] = 0;

    DP[1][2] = 0;
    DP[2][2] = 1;
    DP[3][2] = 0;

    DP[1][3] = 1;
    DP[2][3] = 1;
    DP[3][3] = 1;

    // 테스트할 횟수 입력
    cin >> testCase;

    // 입력받은 숫자 중 최대값을 저장, 같은 계산을 중복하는 경우를 방지
    int Max = 3;
    for (int count = 0; count < testCase; count++)
    {
        // 정수 입력
        cin >> input;

        // 입력받은 숫자가 Max보다 크면 DP 계산, 그렇지 않을 경우 저장된 값을 이용
        if (input > Max)
        {
            // Max의 다음 숫자부터 DP 계산
            // 이때, 방법의 수를 1000000009로 나눈 나머지로 출력하므로 항상 모듈러 연산을 한다.
            for (int index = Max + 1; index <= input; index++)
            {
                DP[1][index] = (DP[2][index - 1] + DP[3][index - 1]) % 1000000009;
                DP[2][index] = (DP[1][index - 2] + DP[3][index - 2]) % 1000000009;
                DP[3][index] = (DP[1][index - 3] + DP[2][index - 3]) % 1000000009;
            }

            Max = input;
        }

        // 결과값 출력

        cout << (DP[1][input] + DP[2][input] + DP[3][input]) % 1000000009 << '\n';
    }

    return 0;
}