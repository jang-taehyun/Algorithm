/*
problem : n자리 이친수(이진수 중 첫 번째 숫자가 1이면서, 1이 연속으로 2번 이상 나타나지 않는 수)의 개수를 구해라
input : 숫자의 길이 n
output : 숫자의 길이가 n인 이친수

idea : bottom-up 방식으로 해결
1. n=1일 때, 이친수의 개수 1
   1) 끝자리가 0인 이친수를 만들 수 있는 방법 : n=0에서 끝자리가 0 또는 1일 때, 맨 오른쪽에 0을 붙인다
      -> 없음
   2) 끝자리가 1인 이친수를 만들 수 있는 방법 : n=0에서 끝자리가 0일 때, 맨 오른쪽에 1을 붙인다
      -> 1
2. n=2일 때, 이친수의 개수 1
   1) 끝자리가 0인 이친수를 만들 수 있는 방법 : n=1에서 끝자리가 0 또는 1일 때, 맨 오른쪽에 0을 붙인다
      -> 1 + 0 = 10
   2) 끝자리가 1인 이친수를 만들 수 있는 방법 : n=1에서 끝자리가 0일 때, 맨 오른쪽에 1을 붙인다
      -> 없음
3. n=3일 때, 이친수의 개수 2
   1) 끝자리가 0인 이친수를 만들 수 있는 방법 : n=2에서 끝자리가 0 또는 1일 때, 맨 오른쪽에 0을 붙인다
      -> 10 + 0 = 100
   2) 끝자리가 1인 이친수를 만들 수 있는 방법 : n=2에서 끝자리가 0일 때, 맨 오른쪽에 1을 붙인다
      -> 10 + 1 = 101
4. n=4일 때, 이친수의 개수 3
   1) 끝자리가 0인 이친수를 만들 수 있는 방법 : n=3에서 끝자리가 0 또는 1일 때, 맨 오른쪽에 0을 붙인다
      -> 100 + 0 = 1000, 101 + 0 = 1010
   2) 끝자리가 1인 이친수를 만들 수 있는 방법 : n=3에서 끝자리가 0일 때, 맨 오른쪽에 1을 붙인다
      -> 100 + 1 = 1001
5. 이를 통해 관계식 도출
   -> DP[i][j] : i자리 이친수 중 j로 끝나는 이친수의 개수(j = 0, 1)
   -> DP[i][0] = DP[i-1][0] + DP[i-1][1]
      DP[i][1] = DP[i-1][0]
*/

#include <iostream>
using namespace std;

int main()
{
    // 숫자의 길이 n
    int length = 0;
    // i자리 이친수 중 j로 끝나는 이친수의 개수를 저장할 2차원 배열
    // 입력값이 91을 넘지 않으므로 배열의 크기를 91로 지정, n이 커질수록 int형이 담을 수 있는 숫자보다 커지므로 long long으로 선언
    long long DP[91][2];

    // n=1일 때, DP 초기화
    DP[1][0] = 0;
    DP[1][1] = 1;

    // 숫자의 길이 n 입력
    cin >> length;

    // n=2부터 length까지 DP 계산
    for (int i = 2; i <= length; i++)
    {
        DP[i][0] = DP[i - 1][0] + DP[i - 1][1];
        DP[i][1] = DP[i - 1][0];
    }

    // 결과값 출력
    cout << DP[length][0] + DP[length][1];

    return 0;
}