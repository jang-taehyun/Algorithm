/*
problem : n개의 정수 중 연속된 몇 개의 수를 골라 가장 큰 합을 만들어라
input : n개의 정수
output : 연속된 몇 개의 수를 골라 만든 가장 큰 합 m

idea
1. 10, -4, 3, 1, -35, 12, 21, -1이라는 숫자가 주어졌다고 하고, 각각을 a1, a2, a3, a4, a5, a6, a7, a8이라고 하자.
2. a1=10을 반드시 포함해서 만들 수 있는 가장 큰 합을 구하자
   -> 자기 자신을 포함하는 방법 밖에 없다.
   -> m=10
3. a2=(-4)를 반드시 포함해서 만들 수 있는 가장 큰 합을 구하자
   -> a1을 포함해서 만드는 방법: 10+(-4)=6
   -> a1을 포함하지 않고 자기 자신만 포함하는 방법: (-4)
   -> m=6
4. a3=3을 반드시 포함해서 만들 수 있는 가장 큰 합을 구하자
   -> a1, a2를 포함해서 만드는 방법: 10+(-4)+3 = 9
   -> a2를 포함해서 만드는 방법: (-4)+3 = -1
   -> 자기 자신만 포함하는 방법: 3
   -> m=9
4. a4=1을 반드시 포함해서 만들 수 있는 가장 큰 합을 구하자
   -> a1,a2,a3를 포함해서 만드는 방법: 10+(-4)+3+1 = 10
   -> a2,a3를 포함해서 만드는 방법: (-4)+3+1 = 0
   -> a3를 포함해서 만드는 방법: 3+1 = 4
   -> 자기 자신만 포함하는 방법: 1
   -> m=10
5. a5=(-35)을 반드시 포함해서 만들 수 있는 가장 큰 합을 구하자
   -> a1,a2,a3,a4를 포함해서 만드는 방법: 10+(-4)+3+1+(-35) = -25
   -> a2,a3,a4를 포함해서 만드는 방법: (-4)+3+1+(-35) = -35
   -> a3,a4를 포함해서 만드는 방법: 3+1+(-35) = -31
   -> a4를 포함해서 만드는 방법: 1+(-35) = -34
   -> 자기 자신만 포함하는 방법: -35
   -> m=-25
5. a6=12을 반드시 포함해서 만들 수 있는 가장 큰 합을 구하자
   -> a1,a2,a3,a4,a5를 포함해서 만드는 방법: 10+(-4)+3+1+(-35)+12 = -13
   -> a2,a3,a4,a5를 포함해서 만드는 방법: (-4)+3+1+(-35)+12 = -23
   -> a3,a4,a5를 포함해서 만드는 방법: 3+1+(-35)+12 = -19
   -> a4,a5를 포함해서 만드는 방법: 1+(-35)+12 = -22
   -> a5를 포함해서 만드는 방법: (-35)+12 = -23
   -> 자기 자신만 포함하는 방법: 12
   -> m=12
6. 이 과정을 보면, 결국 이전에 만들어진 최대 값에 ai를 더하는 방법
   또는 자기 자신부터 연속을 시작해 최대 값을 만드는 과정 2가지를 비교하면
   ai를 반드시 포함해서 만들 수 있는 가장 큰 합을 구할 수 있다.
5. 이를 이용해 관계식 도출
   -> DP[i] = ai을 반드시 포함해서 만들 수 있는 가장 큰 합
      DP[i] = max(DP[i-1]+ai, ai)
*/

#include <iostream>
using namespace std;

int Max(int _x, int _y) { return _x > _y ? _x : _y; }

int main()
{
    // 정수의 개수 N;
    int N = 0;
    // ai를 포함해 만들 수 있는 가장 큰 합을 저장할 배열
    // 이때, 초기값을 입력된 정수로 설정하면, 입력값을 저장할 배열을 따로 선언하지 않아도 되므로 메모리를 아낄 수 있다.
    int DP[100000];
    // 출력할 결과를 저장
    int result = 0;

    // 정수의 개수와 정수 입력
    cin >> N;
    for (int index = 0; index < N; index++)
        cin >> DP[index];

    // 2번째 요소부터 N번째 요소까지 반복문을 돌면서 DP 계산
    // DP[1] == ai 이므로 첫번째 요소는 이 과정을 생략한다.
    for (int index = 1; index < N; index++)
        DP[index] = Max(DP[index - 1] + DP[index], DP[index]);

    // DP에 저장된 값 중 가장 큰 값을 찾아 출력
    result = DP[0];
    for (int index = 1; index < N; index++)
        result = Max(result, DP[index]);
    cout << result;

    return 0;
}