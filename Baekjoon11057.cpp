/*
problem : 오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다.
          수의 길이 n(1 <= n <= 1000)이 주어졌을 때, (오르막 수의 개수 % 10,007)를 구해라.
input : 수의 길이 n(1 <= n <= 1000)
output : 오르막 수의 개수 % 10007
가정 : 수는 0으로 시작할 수 있다.

idea
1. n=1일 때, 오르막 수의 개수는 0부터 9까지 이므로 10개
2. n=2일 때, 오르막 수의 개수 구하기
  - 두 번째 자리가 0이면, 첫 번째 자리에는 0이 올 수 있다.(1가지)
    -> 00
  - 두 번째 자리가 1이면, 첫 번째 자리에는 0, 1이 올 수 있다.(2가지)
    -> 01, 11
  - 두 번째 자리가 2이면, 첫 번째 자리에는 0, 1, 2이 올 수 있다.(3가지)
    -> 02, 12, 22
  - 두 번째 자리가 3이면, 첫 번째 자리에는 0, 1, 2, 3이 올 수 있다.(4가지)
    -> 03, 13, 23, 33
  - 결국 두 번째 자리가 i라면, 첫 번째 자리에는 0부터 i까지 올 수 있다.
    -> 0i, 1i, 2i, ... , ii
  - 이를 수식으로 나타내면 다음과 같다.
    -> (수의 길이가 2일 때, 마지막 자리에 i가 올 수 있는 경우의 수)
        = (수의 길이가 1일 때, 마지막 자리에 0이 올 수 있는 경우의 수) +
          (수의 길이가 1일 때, 마지막 자리에 1이 올 수 있는 경우의 수) +
          (수의 길이가 1일 때, 마지막 자리에 2가 올 수 있는 경우의 수) +
          ...                                                   +
          (수의 길이가 1일 때, 마지막 자리에 i가 올 수 있는 경우의 수)
3. 이를 이용해서 관계식을 도출한다.
  - dp[i][k] : 수의 길이가 i일 때, 마지막 자리에 숫자 k가 올 수 있는 경우의 수
  - dp[i][k] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + ... + dp[i-1][k])
  - 이때, (dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + ... + dp[i-1][k-1])은 dp[i][k-1]과 같으므로 최종 관계식은 다음과 같다,
    dp[i][k] = dp[i][k-1] + dp[i-1][k]
4. 이때 dp[i][k]를 계산할 때마다, 10007를 나눠준다.
  - dp[i][k]는 기하급수적으로 숫자가 커지기 때문에 int형이 저장할 수 있는 공간을 넘지 않게 한다.
5. 이를 수의 길이 n까지 계산한 후에, ((dp[n][0]+dp[n][1]+...+dp[n][9])%10007)의 값을 출력한다.
*/

#include <iostream>
#include <cstring>
using namespace std;

int main()
{
    // 수의 길이 n
    int n = 0;
    // 수의 길이가 i일 때, 마지막 자리에 숫자 k가 올 수 있는 경우의 수를 저장할 이차원 배열 dp
    // -> 수의 길이는 1001을 넘지 않고, 숫자는 0부터 9까지 올 수 있으므로
    //    가로의 길이는 1001, 세로의 길이를 10으로 지정한다.
    int dp[1001][10];
    // 결과값 res
    int res = 0;

    // dp 초기화
    memset(dp, 0, sizeof(dp));

    // n=1일 때, 오르막 수의 개수 저장
    // -> n=1일때는, 모두 1이다.
    for (int i = 0; i < 10; i++)
        dp[1][i] = 1;

    // 수의 길이 입력
    cin >> n;

    // 관계식을 이용해, 2부터 n까지 오르막 수의 개수 계산
    for (int length = 2; length <= n; length++)
    {
        // 수의 길이가 i이고 마지막에 오는 숫자가 0~9일때, 오르막 수의 개수 계산
        // 이때, 연산을 할 때마다, 10007로 나눠준다.
        dp[length][0] = 1;
        for (int i = 1; i <= 10; i++)
            dp[length][i] = (dp[length][i - 1] + dp[length - 1][i]) % 10007;
    }

    // 결과 출력
    for (int i = 0; i < 10; i++)
        res = (res + dp[n][i]) % 10007;
    cout << res;

    return 0;
}