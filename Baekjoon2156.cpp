/*
problem : 포도주의 개수 n과 각 포도주에 들어있는 양 v가 주어지고, 연속으로 놓여있는 3잔을 모두 마실 수 없을 때,
마실 수 있는 포도주의 양 중 최대값을 구하라.
input : 포도주의 개수 n(1 <= n <=10000), 각 포도주에 들어있는 양 v(0 <= v <= 1000)
output : 마실 수 있는 포도주의 양 중 최대값

idea
- 포도주가 6잔이 주어지고, 각 포도주에 들어있는 양 v가 다음과 같다고 가정하자.
  6, 10, 13, 9, 8, 1
- n=1일 때 나오는 경우
  - n=1을 선택하는 경우 : 6
  - n=1을 선택하지 않는 경우 : 0
- n=2일 때 나오는 경우
  - n=2을 선택할 때
    - n=1을 선택하고 n=2을 선택하는 경우 : 6+10
    - n=1을 선택하지 않고, n=2을 선택하는 경우 : 10
  - n=2을 선택하지 않을 때
    - n=1을 선택하고, n=2을 선택하지 않는 경우 : 6
    - n=1을 선택하지 않고, n=2을 선택하지 않는 경우 : 0
- n=3일 때 나오는 경우는 다음과 같다.
  - n=3을 선택할 때
    - n=1을 선택하고 n=2을 선택하고 n=3을 선택하는 경우 : 조건에 위배되므로 고려하지 않는다.
    - n=1을 선택하고 n=2을 선택하지 않고, n=3을 선택하는 경우(n-2을 선택하지 않는 경우) : 6+13
    - n=1을 선택하지 않고, n=2을 선택하고, n=3을 선택하는 경우(n-1을 선택하지 않는 경우) : 10+13
  - n=3을 선택하지 않을 때
    - n=1과 n=2을 선택하는 경우 : 6+10
    - n=1을 선택하고 n=2을 선택하지 않는 경우 : n=1과 n=2을 선택하는 경우보다 항상 작으므로 고려하지 않는다.
    - n=1을 선택하지 않고 n=2을 선택하는 경우 : n=1과 n=2을 선택하는 경우보다 항상 작으므로 고려하지 않는다.
- n=4일 때 나오는 경우는 다음과 같다.
  - n=4을 선택할 때
    1) n-2을 선택하지 않는 경우(n=2을 선택하지 않는 경우) : 6+13+9
      -> (n=1일 때 최대값) + (n=3 선택) + (n=4 선택)
    2) n-1을 선택하지 않는 경우(n=3을 선택하지 않는 경우) : 6+10+9
      -> (n=2일 때 최대값) + (n=4 선택)
  - n=4을 선택하지 않을 때
    3) n-1과 n-2을 선택하는 경우(n=2와 n=3을 선택하는 경우) : 10+13
      -> (n=3일 때 최대값)
  - 이중 최대값은 1), 2), 3) 경우 중 가장 큰 값이 된다.
- 이를 이용해 관계식 도출
  - dp[i] : i번째 잔에서 얻을 수 있는 최대값
    dp[i] = Max(dp[i-3]+volume[i-1]+volume[i],
                dp[i-2]+volume[i],
                dp[i-1])
*/

#include <iostream>
#include <cstring>
using namespace std;

int Max(int x, int y, int z)
{
    int arr[3] = { x, y, z };
    int res = 0;
    for (int i = 0; i < 3; i++)
        if (res < arr[i])
            res = arr[i];
    return res;
}

int main()
{
    // 포도잔의 개수 n
    int n = 0;
    // 포도잔에 들어있는 양을 저장할 배열 volume
    int volume[10001];
    // k경우에서 나올 수 있는 최대값(관계식)을 저장할 배열 dp
    // 포도잔의 개수가 10001을 넘지 않으므로 column의 길이를 10001로 설정
    int dp[10001];

    // volume과 dp 초기화
    memset(volume, 0, sizeof(volume));
    memset(dp, 0, sizeof(dp));

    // 포도잔의 개수 및 포도잔에 들어있는 양 입력
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> volume[i];

    // n이 1~2까지 초기화
    dp[1] = volume[1];
    dp[2] = dp[1] + volume[2];

    // 3부터 n까지 관계식을 이용해 각 경우에서 나올 수 있는 최대값 계산 및 저장
    for (int i = 3; i <= n; i++)
        dp[i] = Max(dp[i - 3] + volume[i - 1] + volume[i], dp[i - 2] + volume[i], dp[i - 1]);

    // 최대값 출력
    cout << dp[n];

    return 0;
}
/*
- 틀린 이유
관계식을 복잡하게 도출
*/