/*
problem : n개의 집을 각각 빨강(r), 초록(g), 파랑(b)으로 칠하되, 서로 인접한 집들은 서로 다른 색깔로 칠하는 방법의 수 중 비용이 최소가 되는 방법을 구해라
input : 집의 수(n), 빨강, 초록, 파랑을 칠하는 비용
output : 모든 집을 칠하는 비용의 최솟값

idea
1. 1번째 집을 r, g, b로 칠하는 비용을 저장한다.
2. 1번째 집을 r, g, b로 칠하는 비용에 2번째 집에 r, g, b로 칠하는 비용을 각각 더한다.
3. 2번째 집을 r, g, b로 칠하는 비용에 3번째 집에 r, g, b로 칠하는 비용을 각각 더한다.
-> dp[i][k] : i번째 집을 k 색깔로 칠했을 때까지의 최소 비용(2 <= i <= 1000, 0 <= k <= 2)
   i번째 집을 r(0)로 칠했을 때까지의 최소 비용 : dp[i][0] = min(dp[i-1][1] + dp[i-1][2]) + price[0]
   i번째 집을 g(1)로 칠했을 때까지의 최소 비용 : dp[i][1] = min(dp[i-1][0] + dp[i-1][2]) + price[1]
   i번째 집을 b(2)로 칠했을 때까지의 최소 비용 : dp[i][2] = min(dp[i-1][0] + dp[i-1][1]) + price[2]
*/

#include <iostream>
using namespace std;

int min(int n1, int n2) { return n1 < n2 ? n1 : n2; }

int main()
{
    // 집의 개수
    int n;
    // 최소값을 구할 2차원 배열
    // r=0, b=1, g=2로 설정 & 집의 수는 1001을 넘지 않으므로 배열의 크기를 1001로 설정하고 1부터 시작
    int dp[1001][3];
    // r=0, b=1, g=2의 가격
    int price[3];

    // 집의 개수와 1번째 집을 칠하는 비용 입력
    cin >> n;
    for (int i = 0; i < 3; i++)
        cin >> price[i];

    // 1번째부터 시작하므로, 1번째 집에 색깔을 칠하는 비용을 초기화
    dp[1][0] = price[0];
    dp[1][1] = price[1];
    dp[1][2] = price[2];

    // n까지 반복문을 돌면서 각 경우에서 나올 수 있는 최소값 구하기
    for (int i = 2; i <= n; i++)
    {
        // price 입력
        for (int k = 0; k < 3; k++)
            cin >> price[k];

        // 관계식을 이용해, i번째 집을 k 색깔로 칠할때 발생하는 최소 비용 계산
        dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]) + price[0];
        dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) + price[1];
        dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + price[2];
    }

    // 3가지 경우 중 최소값 찾기
    int res = dp[n][0];
    for (int i = 0; i < 3; i++)
        if (res > dp[n][i])
            res = dp[n][i];

    cout << res;

    return 0;
}

/*
이전 방식 : 1번째 집을 각각 r, g, b로 칠하는 방법에서 시작해, 다음 집을 칠할 때 최소 비용을 더하는 방식
1. 1번째 집을 r, g, b로 칠한다.
2. 1번째 집을 r로 칠했을 때, 2번째 집을 g와 b 중 비용이 최소인 색을 고르고,
   1번째 집을 칠한 비용과 2번째 집을 칠한 비용을 합친다.
3. 1번째 집을 g 또는 b로 칠했을 때, 2번과 같은 방법을 사용
문제점 : 이전 번째의 집을 최솟값으로 칠했다고 무조건 다음 집도 최솟값으로 칠할 수 있는 것은 아니다.
-> 점화식을 세우지 않고 풀었기 때문에 발생하는 문제
*/