/*
problem : 정수 n을 1, 2, 3의 합으로 나타내는 방법의 수를 구해라
input : 정수 n (1 <= n <= 1,000,000)
output : 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009으로 나눈 나머지 출력

idea
- 정수 n을 1, 2, 3의 합으로 나타내는 방법의 수 = k(n)
1) n=1일 때, 1을 1, 2, 3의 합으로 나타내는 방법
   -> 1
   -> k(1) = 1
2) n=2일 때, 2을 1, 2, 3의 합으로 나타내는 방법
   -> n=1에서 오른쪽에 (+1)를 하는 방법 : 1+1
   -> 2
   -> k(2) = 2
3) n=3일 때, 3을 1, 2, 3의 합으로 나타내는 방법
   -> n=1에서 오른쪽에 (+2)를 하는 방법 : 1+2
   -> n=2에서 오른쪽에 (+1)를 하는 방법 : 1+1+1, 2+1
   -> 3
   -> k(3) = 4
4) n=4일 때, 4를 1, 2, 3의 합으로 나타내는 방법
   -> n=1에서 오른쪽에 (+3)을 하는 방법 : 1+3
   -> n=2에서 오른쪽에 (+2)을 하는 방법 : 1+1+2, 2+2
   -> n=3에서 오른쪽에 (+1)을 하는 방법 : 1+2+1, 1+1+1+1, 2+1+1, 3+1
   -> k(4) = 7
5) 이를 이용해 관계식 도출
   - 정수 n을 1, 2, 3의 합으로 나타내는 방법의 수를 k(n)이라고 할 때,
     k(n) = k(n-1) + k(n-2) + k(n-3)
6) 테스트 케이스가 존재하므로 반복문을 돌리되, 이전에 계산한 k(n)을 저장할 배열이 필요하다.
   그리고 k(n)을 계산할 때마다 1,000,000,009로 나눈다.
   최악의 경우, k(n)이 계산될 때 int의 범위가 넘어가므로 long long를 사용한다.
*/

#include <iostream>
#include <cstring>
using namespace std;

int main()
{
    // 테스트케이스 T
    int T = 0;
    // 테스트 케이스마다 입력받는 정수 n
    int n = 0;
    // n을 1, 2, 3의 합으로 나타내는 방법의 수 k(n)을 저장할 1차원 배열 dp
    long long dp[1000001];
    // 현재까지 계산된 index를 저장하는 end
    int end = 0;

    // dp를 모두 0으로 초기화 후, n이 1, 2, 3일 때 초기화
    memset(dp, 0, sizeof(dp));
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 4;

    // end 초기화
    end = 3;

    // 테스트 케이스 입력
    cin >> T;

    // 각 테스트 케이스마다 n을 1,2,3의 합으로 나타내는 방법의 수를
    // 1,000,000,009로 나눈 나머지로 출력
    while (T--)
    {
        // 정수 n 입력
        cin >> n;

        // dp[n]이 계산되지 않았다면, (end+1)부터 n까지 계산
        if (!dp[n])
        {
            for (int i = end + 1; i <= n; i++)
                dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % 1000000009;

            // end값 업데이트
            end = n;
        }

        cout << dp[n] << '\n';
    }

    return 0;
}