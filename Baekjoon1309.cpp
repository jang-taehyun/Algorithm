/*
problem : 2*n 배열에 사자를 배치할 수 있는 경우의 수를 구해라
input : row의 개수 n(1 <= n <= 100,000)
output : (2*n 배열에 사자를 배치할 수 있는 경우의 수) % 9901

idea
1. n=1일 때, 사자를 배치할 수 있는 경우는 xx, ox, xo 3가지 경우가 존재한다.
2. n=2일 때, 2*2 배열에서 사자를 배치할 수 있는 경우는 첫 번째 row 줄의 상태에 따라 달라진다.
   - 첫 번째 row 줄의 상태가 xx로 끝났다면, 두 번째 row 줄에서는 xx, ox, xo가 올 수 있다.
   - 첫 번째 row 줄의 상태가 ox로 끝났다면, 두 번째 row 줄에서는 xx, xo가 올 수 있다.
   - 첫 번째 row 줄의 상태가 xo로 끝났다면, 두 번째 row 줄에서는 xx, ox가 올 수 있다.
3. 이를 이용해 관계식을 도출한다.
   - xx상태를 0, ox상태를 1, xo상태를 2라고 할 때, dp[i][k]를 i번째 row줄의 k 상태의 개수라고 하자.
   - dp[i][0] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2]    -> i번째 row줄의 상태가 xx가 올려면, i-1번째 row줄의 상태는 xx, ox, xo가 되야한다.
     dp[i][1] = dp[i-1][0] + dp[i-1][2]                 -> i번째 row줄의 상태가 ox가 올려면, i-1번째 row줄의 상태는 xx, xo가 되야한다.
     dp[i][2] = dp[i-1][0] + dp[i-1][1]                 -> i번째 row줄의 상태가 xo가 올려면, i-1번째 row줄의 상태는 xx, ox가 되야한다.
4. 2*n 배열에 사자를 배치할 수 있는 경우의 수는 dp[n][0] + dp[n][1] + dp[n][2]이다.
*/

#include <iostream>
#include <cstring>
using namespace std;

int main()
{
    // row줄의 개수 n
    int n = 0;
    // row줄의 상태를 저장할 2차원 배열 dp
    // input의 최대 값은 100000이고, 1부터 시작하므로 열의 크기를 100001로 지정
    int dp[100001][3];

    // dp 초기화
    memset(dp, 0, sizeof(dp));

    // n=1일 때, dp 초기화
    for (int state = 0; state < 3; state++)
        dp[1][state] = 1;

    // row줄의 개수 입력
    cin >> n;

    // 2부터 n까지 관계식을 이용해, row줄의 k 상태의 개수 계산
    // 이때 계산을 할 때마다, 9901로 나눈 나머지를 저장한다.
    for (int i = 2; i <= n; i++)
    {
        dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % 9901;
        dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % 9901;
        dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % 9901;
    }

    // 결과값 출력
    cout << (dp[n][0] + dp[n][1] + dp[n][2]) % 9901;

    return 0;
}

/*
해결하지 못한 이유
- 2*n을 2개로 나눠 각각의 경우의 수를 구해 합치려고 했기 때문
  -> 이렇게 하면 관계식 유추를 할 수 없고, 매우 어려움
  -> 문제를 어렵게 접근함
*/